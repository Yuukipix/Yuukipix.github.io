<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>静态托管Blog:Hexo+Github.io+Gitee镜像+个人域名+CDN</title>
    <url>/posts/MyBlog/</url>
    <content><![CDATA[<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>由于我事先已经安装，所以仅留下Git下载地址</p>
<p><a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>前往<a href="https://nodejs.org/zh-cn/">nodejs.org</a>下载并安装长期维护版</p>
<h3 id="使用npm安装Hexo（全局安装）"><a href="#使用npm安装Hexo（全局安装）" class="headerlink" title="使用npm安装Hexo（全局安装）"></a>使用npm安装Hexo（全局安装）</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>

<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<ol>
<li><code>npx hexo &lt;command&gt;</code></li>
<li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code></li>
</ol>
<h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>使用以下命令初始化Hexo ，会在&lt;folder&gt;中新建所需要的文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第一篇Blog"><a href="#第一篇Blog" class="headerlink" title="第一篇Blog"></a>第一篇Blog</h3><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>使用以下命令新建一篇博客</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo new &lt;文章名&gt;</span><br></pre></td></tr></table></figure>

<p>这时候就能在</p>
<p>./Hexo/source/_posts目录下看到刚才建立的文章的markdown文件</p>
<h4 id="本地查看文章"><a href="#本地查看文章" class="headerlink" title="本地查看文章"></a>本地查看文章</h4><p>使用以下命令生成静态文件，并开启本地Web服务器查看效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo clean	//删除生成的文件和缓存</span><br><span class="line">npx hexo generate	//生成静态文件</span><br><span class="line">npx hexo server	//启动本地Web服务器</span><br></pre></td></tr></table></figure>

<p>上传文章到Gitpage</p>
<p>可使用以下命令上传到Gitpage，不过在此之前需要对./Hexo目录下的**_config.yml**进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: &lt;你的gitpage地址&gt;</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;你的gitpage地址&gt;</span><br><span class="line">  branch: master	//要特别说明一下上传的分支，github创建的gitpage默认使用main分支，需要在仓库的gitpage相关设置更改分支为master分支，或者干脆直接上传到main分支里面</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure>

<p>如果之前没有配置git，还需配置git，网上教程比较多，不再赘述。</p>
<h3 id="上传图片踩坑"><a href="#上传图片踩坑" class="headerlink" title="上传图片踩坑"></a>上传图片踩坑</h3><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="安装hexo-asset-image修改版插件"><a href="#安装hexo-asset-image修改版插件" class="headerlink" title="安装hexo-asset-image修改版插件"></a>安装hexo-asset-image修改版插件</h5><p><a href="https://github.com/xcodebuild/hexo-asset-image">https://github.com/xcodebuild/hexo-asset-image</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/xcodebuild/hexo<span class="literal">-asset</span><span class="literal">-image</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<h5 id="开启post-asset-folder"><a href="#开启post-asset-folder" class="headerlink" title="开启post_asset_folder"></a>开启post_asset_folder</h5><p>关于post_asset_folder，官方文档这样描述：</p>
<blockquote>
<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
</blockquote>
<p>编辑<strong>Hexo根目录</strong>下的**_config.yml**</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h4><p>使用以下命令新建一篇文章，将会在 *<em>source\_posts\*</em> 目录下生成 <strong>new_blog.md</strong> 和 <strong>new_blog文件夹</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo new <span class="string">&quot;new_blog&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<strong>new_blog.md</strong>中<strong>使用相对路径</strong>引用<strong>new_blog文件夹</strong>下的1.jpg</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](Blog\1.jpg)</span><br></pre></td></tr></table></figure>

<p>清空Hexo缓存，重新编译后开启本地web测试效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo clean</span><br><span class="line">npx hexo generate</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>

<p>本地web可正常显示，图片路径一切正常</p>
<p><img src="/posts/MyBlog/1.png" alt="测试正常"></p>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>SOCKS5&amp;HTTP代理</title>
    <url>/posts/SOCKS5&amp;HTTP%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zgao.top/%E5%A5%87%E5%AE%89%E4%BF%A1%E5%AE%9E%E4%B9%A0%E4%BA%94-socks5%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/">《奇安信实习(五)-Socks5协议抓包分析》</a><br><a href="https://reezon.github.io/2018/05/23/%E5%85%B3%E4%BA%8Ess(%E9%85%B8%E9%85%B8)%E5%92%8Cssr(%E9%85%B8%E9%85%B8%E4%B9%B3)%EF%BC%8C%E8%BF%98%E6%9C%89vpn%E5%92%8Csocks5/">《关于ss(酸酸)和ssr(酸酸乳)，还有vpn和socks5》</a></p>
<h2 id="Socks5-代理"><a href="#Socks5-代理" class="headerlink" title="Socks5 代理"></a>Socks5 代理</h2><ul>
<li>socks(socket security)是一种网络传输协议，它工作在OSI七层模型中的第五层/会话层。</li>
<li>socks5比socks4协议多了验证、IPv6、UDP支持。</li>
<li>socks5代理是把你的网络数据由代理服务器转发到目的地，这个过程中你是没有一条专用通道的，只是数据包的发出，然后被代理服务器收到，然后代理服务器再进行转发，整个过程并没有额外的处理。</li>
<li>socks5 协议并不负责代理服务器的数据传输环节，此协议只是在Client/Server两端真实交互之间，建立起一条从客户端到代理服务器的授信连接。</li>
</ul>
<h2 id="Socks5和VPN的区别"><a href="#Socks5和VPN的区别" class="headerlink" title="Socks5和VPN的区别"></a>Socks5和VPN的区别</h2><ul>
<li>vpn是建立一条静态路由0.0.0.0/0，所有的应用都走这条路出去。</li>
<li>vpn会给你分配一个内网地址（例如L2TP、PPTP），socks5不会。</li>
<li>vpn不需要配置端口号，socks5需要。</li>
</ul>
<h2 id="Socks5的交互方式"><a href="#Socks5的交互方式" class="headerlink" title="Socks5的交互方式"></a>Socks5的交互方式</h2><p>socks5  是一个Client/Server交互的协议，交互大概分为这么几步：</p>
<ol>
<li>客户端发送认证协商</li>
<li>代理服务器就认证协商进行回复（如拒绝则本次会话结束）<ol>
<li>如需GSSAPI或用户名/密码认证，客户端发送认证信息</li>
<li>代理服务器就对应项进行鉴权，并进行回复或拒绝</li>
</ol>
</li>
<li>客户端发送希望连接的目标信息</li>
<li>代理服务器就连接信息进行确认或拒绝</li>
<li>【非协议内容】：代理服务器连接目标并 pipe 到客户端Socks5协议并不负责代理服务器的数据传输环节，此协议只是在C/S两端真实交互之间，建立起一条从客户端到代理服务器的授信连接</li>
</ol>
<h2 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h2><p>HTTP代理工作在OSI七层模型中的第七层/应用层。HTTP代理客户机的HTTP(S)访问，主要代理浏览器访问网页。</p>
<h2 id="socks5和HTTP代理的对比"><a href="#socks5和HTTP代理的对比" class="headerlink" title="socks5和HTTP代理的对比"></a>socks5和HTTP代理的对比</h2><ul>
<li>socks5工作在比HTTP代理更低的层次</li>
<li>socks5使用握手协议来通知代理软件其客户端试图进行的socks连接，然后尽可能透明地进行操作（不对请求或响应进行修改），而HTTP代理可能会解释和重写报头</li>
<li>socks5代理支持UDP协议，而HTTP代理不能</li>
</ul>
<h2 id="网络示意图"><a href="#网络示意图" class="headerlink" title="网络示意图"></a>网络示意图</h2><p><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/1.png"></p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>搭建socks5和HTTP代理（Clash Docker版）</p>
<p>代理：Socks5代理（IP：172.16.7.233:7891）HTTP代理（IP：172.16.7.233:7890）<br>目标网站：<a href="http://172.16.3.9/backend/getIP.php">http://172.16.3.9/backend/getIP.php</a>（可返回访问者IP）</p>
<p>软件环境：Win10系统电脑、SSTAP、WireShark、CURL<br>​</p>
<p>流量路径：本机浏览器–&gt;HTTP代理（如果有）–&gt;SSTAP虚拟网卡–&gt;物理网卡–&gt;socks代理服务器–&gt;HTTP代理服务器（如果有）<br>​</p>
<p>流量分析：使用WireShark在<strong>物理网卡</strong>接口上抓取流量进行分析<br>注意：默认情况下，只有socks代理的端口设置为1080时，wireshark才能识别为socks协议的流量。</p>
<p>Q：为什么选择SSATP作为代理客户端软件？<br>A：因为SSTAP使用的代理模式是利用虚拟网卡技术在网络层实现的代理工具，所有流量都会被转到虚拟网卡上，这样方便分析所有流量。<br>​</p>
<p>Q：为什么使用Clash作为代理服务端？<br>A：因为Clash自带HTTP和Socks5代理，简单配置一下就能用。</p>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>Socks5代理可以设置密码认证，但是认证时客户端发给服务端的账号密码走TCP协议进行明文传输。</p>
<h3 id="无Socks5代理-无HTTP代理"><a href="#无Socks5代理-无HTTP代理" class="headerlink" title="无Socks5代理 无HTTP代理"></a>无Socks5代理 无HTTP代理</h3><p><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/2.png"><br>此时目标网站返回的IP为我的真实IP。</p>
<h3 id="开启Socks5代理-无HTTP代理"><a href="#开启Socks5代理-无HTTP代理" class="headerlink" title="开启Socks5代理 无HTTP代理"></a>开启Socks5代理 无HTTP代理</h3><p>curl设置socks5代理方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &lt;要访问的地址&gt; --socks5 &lt;host[:port]&gt; --proxy-user &lt;user:password&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/3.png"></p>
<p><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/4.png"></p>
<p>可以看到目标网站返回的IP是我Socks代理的IP，但是我抓到的包中可以看到我的认证账号密码是以明文传输的。<br>密码只由socks服务端用来鉴定客户端是否有权连接，并不用密码对传输的信息进行加密。<br>在TCP三次握手后，建立socks连接，有着极为明显的流量特征（主要体现在TCP报文中的字节流中)。</p>
<h3 id="开启HTTP代理无socks5代理"><a href="#开启HTTP代理无socks5代理" class="headerlink" title="开启HTTP代理无socks5代理"></a>开启HTTP代理无socks5代理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &lt;要访问的地址&gt; -x &lt;host[:port]&gt; --proxy-user &lt;user:password&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/5.png"></p>
<p>仔细看报文，使用HTTP代理时发送的HTTP报文（上图序号4的数据包)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://172.16.3.9/backend/getIP.php</span><br></pre></td></tr></table></figure>

<p>而使用socks代理时，发出的HTTP报文是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /backend/getIP.php</span><br></pre></td></tr></table></figure>

<p>除此之外，使用HTTP代理时，如果设置了认证，那么在发出HTTP报文的时候会有一个专门的字段Proxy-Authorization来发送账号密码。<br><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/6.png"></p>
<h3 id="开启HTTP代理并开启Socks5代理"><a href="#开启HTTP代理并开启Socks5代理" class="headerlink" title="开启HTTP代理并开启Socks5代理"></a>开启HTTP代理并开启Socks5代理</h3><p>此时开启SSTAP代理本机所有流量到socks代理服务器<br><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/7.png"><br>CURL设置HTTP代理<br>WireShark开启抓包<br><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/8.png"><br>虽然返回结果是我的代理服务器的IP（我的HTTP和socks代理的IP地址一样），但是实际上流量是走HTTP代理过了一遍。如果HTTP和SOCKS代理为不同IP，则会返回HTTP代理的IP。<br><img src="/posts/SOCKS5&HTTP%E4%BB%A3%E7%90%86/9.png"><br>上图物理网卡出口抓到的HTTP报文，和上面的仅使用HTTP代理方式发出的报文一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Socks是个很实用的代理协议，但是在连接建立时、传输流量过程中有着极为明显的流量特征。<br>流量加密、反检测、免杀：</p>
<ul>
<li>Socks5+HTTP代理并不会让本来明文传输的浏览加密，但是可以改变请求的IP，服务器看到访问者的IP就是你的代理代理服务器的IP。</li>
<li>如果流量本身没有加密，实战中流控设备很容易识别到客户端连接成功的流量规则。</li>
<li>如果想要加密Socks5的流量，则需要安装魔改版Socks服务端和客户端，比如著名的SS/SSR就是用Socks5来实现的，Cobalt Strike也有相关插件对流量进行加密。</li>
</ul>
<p>可代理的流量：</p>
<ul>
<li>因为HTTP代理工作在应用层，仅能代理HTTP/HTTPS流量，故不能代理SSH或远程桌面等流量，</li>
<li>Socks5则可以代理SSH和远程桌面，但是不走TCP/UDP协议的流量（如ICMP、ARP等）则不能代理</li>
</ul>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>网络</tag>
        <tag>VPN</tag>
        <tag>隧道</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Wireguard打通NAT实现LAN-to-LAN</title>
    <url>/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/</url>
    <content><![CDATA[<p><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/1.png"><br>本次实验是使用Wireguard打通NAT实现公网腾讯云和教务网的互访。<br>应用场景：</p>
<ul>
<li>在内网搭建一台跳板机</li>
<li>通过实验学习内网渗透中的关于网段、流量转发等相关网络知识 </li>
</ul>
<p>Wireguard优势：</p>
<ul>
<li>开源</li>
<li>流量加密</li>
<li>易于配置</li>
<li>生态全（Windows、Linux、Android、iOS、macOS都有客户端）</li>
</ul>
<p>应用条件：</p>
<ul>
<li>一台有公网地址的服务器</li>
<li>内网有一台跳板机（能同时访问内网和外网，不需要有公网地址）</li>
</ul>
<h3 id="安装wireguard"><a href="#安装wireguard" class="headerlink" title="安装wireguard"></a>安装wireguard</h3><p>公网腾讯云：docker版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=wireguard \</span><br><span class="line">  --cap-add=NET_ADMIN \</span><br><span class="line">  --cap-add=SYS_MODULE \</span><br><span class="line">  -e PUID=1000 \</span><br><span class="line">  -e PGID=1000 \</span><br><span class="line">  -e TZ=Europe/London \</span><br><span class="line">  -e SERVERURL=wireguard.domain.com `#optional` \</span><br><span class="line">  -e SERVERPORT=51820 `#optional` \</span><br><span class="line">  -e PEERS=1 `#optional` \</span><br><span class="line">  -e PEERDNS=auto `#optional` \</span><br><span class="line">  -e INTERNAL_SUBNET=10.13.13.0 `#optional` \</span><br><span class="line">  -e ALLOWEDIPS=0.0.0.0/0 `#optional` \</span><br><span class="line">  -p 51820:51820/udp \</span><br><span class="line">  -v /path/to/appdata/config:/config \</span><br><span class="line">  -v /lib/modules:/lib/modules \</span><br><span class="line">  --sysctl=&quot;net.ipv4.conf.all.src_valid_mark=1&quot; \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  linuxserver/wireguard</span><br></pre></td></tr></table></figure>

<p>内网跳板机：直接安装到宿主机</p>
<h3 id="Wireguard基本知识"><a href="#Wireguard基本知识" class="headerlink" title="Wireguard基本知识"></a>Wireguard基本知识</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#wireguard配置文件位置</span><br><span class="line">/etc/wireguard/</span><br><span class="line"></span><br><span class="line">默认配置文件/etc/wireguard/wg0.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用wg-quick 快速连接/断开 接口</span><br><span class="line">wg-quick up &lt;配置文件名&gt;</span><br><span class="line">wg-quick down &lt;配置文件名&gt;</span><br><span class="line"></span><br><span class="line">eg:wg-quick up wg0	//自动读取/etc/wireguard/wg0.conf，连接wg0接口</span><br><span class="line">eg:wg-quick up wg0	//会自动读取/etc/wireguard/wg0.conf，断开wg0接口</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#linuxserver/wireguard 此docker镜像支持使用命令行输出对应节点二维码，使用手机客户端扫码可以快速连接</span><br><span class="line">docker exec -it wireguard /app/show-peer 1 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker镜像中客户端的.conf配置文件目录</span><br><span class="line">/config</span><br></pre></td></tr></table></figure>

<p><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/2.png"></p>
<h3 id="配置wireguard服务器端"><a href="#配置wireguard服务器端" class="headerlink" title="配置wireguard服务器端"></a>配置wireguard服务器端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/wireguard</span><br><span class="line"></span><br><span class="line">vi wg0.conf</span><br><span class="line">将下方红框中的内容填入AllowedIPs</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/3.png"></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#重启wireguard服务端</span><br><span class="line">wg-quick down wg0</span><br><span class="line">wg-quick up wg0</span><br></pre></td></tr></table></figure>

<h3 id="配置wireguard客户端"><a href="#配置wireguard客户端" class="headerlink" title="配置wireguard客户端"></a>配置wireguard客户端</h3><p>获取配置文件（在容器中进行操作）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /config/peer1</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">peer1.conf  peer1.png  privatekey-peer1  publickey-peer1</span><br><span class="line"></span><br><span class="line">vi peer1.conf</span><br></pre></td></tr></table></figure>

<p>复制屏幕上显示的内容，然后稍作修改<br><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/4.png"><br>修改的地方是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">#配置客户端NAT，确保服务器可以访问客户端后面的网络</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">#修改客户端路由的IP段</span><br><span class="line">10.13.13.0/24,10.9.0.0/29</span><br><span class="line">#配置隧道保活时间</span><br><span class="line">PersistentKeepalive = 1</span><br></pre></td></tr></table></figure>

<p>修改后的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 10.13.13.2</span><br><span class="line">PrivateKey = *******************************</span><br><span class="line">ListenPort = 51820</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = *******************************</span><br><span class="line">Endpoint = **************:51820</span><br><span class="line">AllowedIPs = 10.13.13.0/24,10.9.0.0/29</span><br><span class="line">PersistentKeepalive = 1</span><br></pre></td></tr></table></figure>

<p>SSH连接上内网的跳板机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/wireguard</span><br><span class="line"></span><br><span class="line">vi wg0.conf</span><br><span class="line">然后将刚才编辑好的配置文件粘贴进去</span><br><span class="line"></span><br><span class="line">#开启内网客户端与服务器的连接</span><br><span class="line">wg-quick up wg0</span><br><span class="line"></span><br><span class="line">#测试能不能ping通服务器</span><br><span class="line">ping 10.13.13.1</span><br></pre></td></tr></table></figure>

<h3 id="测试服务端能否ping通客户端后的内网"><a href="#测试服务端能否ping通客户端后的内网" class="headerlink" title="测试服务端能否ping通客户端后的内网"></a>测试服务端能否ping通客户端后的内网</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 172.13.1.32</span><br><span class="line"></span><br><span class="line">root@62d21fb82751:/# ping 172.13.1.32</span><br><span class="line">PING 172.13.1.32 (172.13.1.32) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=1 ttl=124 time=50.1 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=2 ttl=124 time=55.8 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=3 ttl=124 time=52.8 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=4 ttl=124 time=50.7 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=5 ttl=124 time=50.1 ms</span><br><span class="line">--- 172.13.1.32 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4005ms</span><br><span class="line">rtt min/avg/max/mdev = 50.119/51.961/55.893/2.221 ms</span><br></pre></td></tr></table></figure>

<p>成功ping通</p>
<h3 id="使用nginx反代内网网站"><a href="#使用nginx反代内网网站" class="headerlink" title="使用nginx反代内网网站"></a>使用nginx反代内网网站</h3><p>因为客户端和服务器端都有172.17.0.0/16这条路由（docker bridge模式默认网段），可能会冲突。<br>我在portainer建立了一个新的docker网络，供wireguard服务端和nginx使用。<br><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/5.png"><br>将刚才配置好的wireguard服务端移动到新建的网络中。<br>然后从dockerhub拉取nginx，新建容器。<br><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/6.png"><br><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/7.png"><br>给宿主机添加一条路由表，其中10.9.0.2是wireguard容器在docker网络中的一个内网地址，添加这条路由的作用是去172.13.1.32的数据包走wireguard进行转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add -net 172.13.1.32 netmask 255.255.255.255 gateway 10.9.0.2</span><br></pre></td></tr></table></figure>

<p>测试在宿主机ping172.13.1.32</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 172.13.1.32</span><br><span class="line"></span><br><span class="line">PING 172.13.1.32 (172.13.1.32) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=1 ttl=123 time=50.7 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=2 ttl=123 time=290 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=3 ttl=123 time=49.2 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=4 ttl=123 time=230 ms</span><br><span class="line">--- 172.13.1.32 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min/avg/max/mdev = 49.233/155.022/290.021/107.176 ms</span><br></pre></td></tr></table></figure>

<p>成功ping通<br>这下只需要配置nginx的反向代理了，因为宿主机都通网了，宿主机下面的容器去172.13.1.32就不用再做配置了<br>​</p>
<p>启动nginx容器，编辑配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>

<p>配置nginx反向代理<br><img src="/posts/%E4%BD%BF%E7%94%A8Wireguard%E6%89%93%E9%80%9ANAT%E5%AE%9E%E7%8E%B0LAN-to-LAN/8.png"><br>到这一步就配置完成了，可以访问ip对应的端口号进行测试查看有没有反代成功</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>VPN</tag>
        <tag>隧道</tag>
        <tag>Wireguard</tag>
        <tag>NGINX反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖配置阿里云Docker镜像加速服务</title>
    <url>/posts/%E7%BE%A4%E6%99%96%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>环境DSM 6.2.3<br>Docker套件版本：18</p>
<h1 id="群晖Web界面设置"><a href="#群晖Web界面设置" class="headerlink" title="群晖Web界面设置"></a>群晖Web界面设置</h1><p>先找到阿里云镜像加速服务，开通<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a><br><img src="/posts/%E7%BE%A4%E6%99%96%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/1.png"></p>
<p>可在Docker套件-注册表中进行如下设置进行加速<br><img src="/posts/%E7%BE%A4%E6%99%96%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/2.png"></p>
<h1 id="SSH连接群晖修改配置文件（可选）"><a href="#SSH连接群晖修改配置文件（可选）" class="headerlink" title="SSH连接群晖修改配置文件（可选）"></a>SSH连接群晖修改配置文件（可选）</h1><p>也可以使用ssh连接到群晖，编辑以下文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /var/packages/Docker/etc/dockerd.json</span><br></pre></td></tr></table></figure>

<p><img src="/posts/%E7%BE%A4%E6%99%96%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/3.png"><br>保险起见，再修改一下这两个配置文件。这两个文件互相映射，改哪个都一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /var/packages/Docker/target/config/dockerd.json</span><br><span class="line">vi /volume1/@appstore/Docker/config/dockerd.json	//volume1是套件保存的位置，根据自己实际情况填写</span><br></pre></td></tr></table></figure>

<p><img src="/posts/%E7%BE%A4%E6%99%96%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/4.png"><br>测试安装一下镜像，速度不错。<br>不过下载Jellyfin依旧可能报错，不知道为什么。</p>
<h1 id="解决Jellyfin多次下载失败"><a href="#解决Jellyfin多次下载失败" class="headerlink" title="解决Jellyfin多次下载失败"></a>解决Jellyfin多次下载失败</h1><p>如果多次下载Jellyfin还是失败，试试直接ssh连上群晖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull jellyfin/jellyfin</span><br></pre></td></tr></table></figure>

<p>这下就不会失败了，等待一会下载好后会在映像中显示出来<br><img src="/posts/%E7%BE%A4%E6%99%96%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/5.png"></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>黑群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理作业-头歌实践平台实验答案</title>
    <url>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A-%E5%A4%B4%E6%AD%8C%E5%AE%9E%E8%B7%B5%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>答案包含以下实验</p>
<p>计算机数据表示实验(HUST)<br>MIPS CPU设计(HUST)</p>
<p>答案：<br><a href="%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(HUST).zip">存储系统设计(HUST).zip</a><br><a href="MIPS_CPU%E8%AE%BE%E8%AE%A1(HUST).zip">MIPS CPU设计(HUST).zip</a> </p>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>黑群晖升级DSM6.2.3-25426</title>
    <url>/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>群晖现在是DSM 6.2.1-23824 Update 6版本，使用第三方手机软件派派助手发现控制台打不开，朋友的DSM 6.2.3-25426却正常。</p>
<p>想到以前群晖老是引导出问题开不了机（能进HappyHacking但是访问IP无反应，需要重做引导才能进系统），我决定升级系统。</p>
<h1 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h1><p>DSM6.2.3 系统引导有 DS3615，DS3617，DS918+ 三种，DS918 支持 UEFI 和 Legacy 启动，支持硬解码。DS3615 和 DS3617 只支持 Legacy 启动，不支持硬解码。</p>
<p>所以我选择的是DS918+。</p>
<p>附1：引导&amp;.pat系统文件</p>
<p>感谢 GXNAS博客<a href="https://wp.gxnas.com/7407.html">https://wp.gxnas.com/7407.html</a></p>
<p>蓝奏云（因限制文件大小仅有引导文件）<a href="https://wwa.lanzoui.com/ipTqOx1j7ej">https://wwa.lanzoui.com/ipTqOx1j7ej</a></p>
<p>附2：会使用到的工具</p>
<p>ChipGenius——查看U盘VID PID</p>
<p>Win32DiskImager——写盘软件 将引导镜像写入U盘</p>
<p>DiskGenius Pro单文件版——格式化U盘、替换文件等</p>
<p>蓝奏云 <a href="https://wwa.lanzoui.com/b05btposd">https://wwa.lanzoui.com/b05btposd</a> 密码:3ttl</p>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><h2 id="简化步骤"><a href="#简化步骤" class="headerlink" title="简化步骤"></a>简化步骤</h2><ol>
<li><p>U盘重做引导</p>
</li>
<li><p>开机后使用WEB界面上传.pat系统文件恢复系统</p>
</li>
<li><p>等待自动重启，升级完成</p>
</li>
</ol>
<h2 id="重做引导"><a href="#重做引导" class="headerlink" title="重做引导"></a>重做引导</h2><ol>
<li><p>黑群晖关机、拔下U盘</p>
</li>
<li><p>U盘插入电脑、使用DiskGenius删除U盘所有分区，然后点击左上角的<strong>保存更改</strong><br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/1.png"></p>
</li>
<li><p>打开ChipGenius查看U盘VID PID<br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/2.png"></p>
</li>
<li><p>关闭DiskGenius和ChipGenius软件，打开Win32DiskImager<br>选择写入的镜像和U盘（一定要确认无误后再写入）<br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/3.png"></p>
</li>
<li><p>关闭Win32DiskImager，重新打开DiskGenius，找到grub.cfg文件，复制到桌面<br>[img4]<br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/4.png"></p>
</li>
<li><p>在桌面找到并打开grub.cfg，修改grub.cfg文件中的VID PID字段（前面的0x不需要动），如果要洗白才需替换SN MAC字段<br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/5.png"></p>
</li>
<li><p>把修改好的grub.cfg文件覆盖到U盘，替换掉原来的grub.cfg<br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/6.png"></p>
</li>
</ol>
<p>至此，U盘引导重做完成</p>
<h2 id="恢复系统"><a href="#恢复系统" class="headerlink" title="恢复系统"></a>恢复系统</h2><ol>
<li>刚才重做好引导的U盘插入黑群晖机器，通电开机</li>
<li>查找主机对应IP（下面给出3种方法）</li>
<li><ol>
<li>使用路由器后台（家庭用户）</li>
<li>使用find.synology.com（学生&amp;无法看到路由器后台用户，查找设备和被查找设备最好在同一个网段或者Vlan中成功率比较高）</li>
<li>端口扫描工具扫描TCP 5000端口（扫整个网段）</li>
</ol>
</li>
<li>在WEB界面上传.pat系统文件，等待群晖恢复后自动重启<br><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/7.png"></li>
</ol>
<p>翻车，别人博客更新了引导后都是提示重新安装新系统，而我是还原，而且我点击还原系统重启后就进不去web了</p>
<p>现在拔掉了原有的硬盘，插入了一个新硬盘，web界面可以正常安装系统了</p>
<p><img src="/posts/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7DSM6.2.3-25426/8.png"></p>
<h2 id="升级完成"><a href="#升级完成" class="headerlink" title="升级完成"></a>升级完成</h2><p>重启开机后系统就升级成功了</p>
<p>检查一下核显硬解或者其他容易出BUG的地方（网卡）看看有没有问题吧</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://mianao.info/2021/07/18/%E9%BB%91%E7%BE%A4%E6%99%96%E5%8D%87%E7%BA%A7%E5%88%B06-2-3">《黑群晖升级到6.2.3》</a><br><a href="https://wp.gxnas.com/7407.html">《关于DSM6.23版本安装/升级的说明及img引导文件（含918硬解补丁文件）和PAT安装包下载地址》</a></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>黑群晖</tag>
      </tags>
  </entry>
</search>
