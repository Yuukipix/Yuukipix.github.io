<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用Wireguard打通NAT实现LAN-to-LAN</title>
    <url>/posts/Wireguard-LANtoLAN/</url>
    <content><![CDATA[<p><img src="/posts/Wireguard-LANtoLAN/1.png"><br>本次实验是使用Wireguard打通NAT实现公网腾讯云和教务网的互访。<br>应用场景：</p>
<ul>
<li>在内网搭建一台跳板机</li>
<li>通过实验学习内网渗透中的关于网段、流量转发等相关网络知识 </li>
</ul>
<p>Wireguard优势：</p>
<ul>
<li>开源</li>
<li>流量加密</li>
<li>易于配置</li>
<li>生态全（Windows、Linux、Android、iOS、macOS都有客户端）</li>
</ul>
<p>应用条件：</p>
<ul>
<li>一台有公网地址的服务器</li>
<li>内网有一台跳板机（能同时访问内网和外网，不需要有公网地址）</li>
</ul>
<h3 id="安装wireguard"><a href="#安装wireguard" class="headerlink" title="安装wireguard"></a>安装wireguard</h3><p>公网腾讯云：docker版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=wireguard \</span><br><span class="line">  --cap-add=NET_ADMIN \</span><br><span class="line">  --cap-add=SYS_MODULE \</span><br><span class="line">  -e PUID=1000 \</span><br><span class="line">  -e PGID=1000 \</span><br><span class="line">  -e TZ=Europe/London \</span><br><span class="line">  -e SERVERURL=wireguard.domain.com `#optional` \</span><br><span class="line">  -e SERVERPORT=51820 `#optional` \</span><br><span class="line">  -e PEERS=1 `#optional` \</span><br><span class="line">  -e PEERDNS=auto `#optional` \</span><br><span class="line">  -e INTERNAL_SUBNET=10.13.13.0 `#optional` \</span><br><span class="line">  -e ALLOWEDIPS=0.0.0.0/0 `#optional` \</span><br><span class="line">  -p 51820:51820/udp \</span><br><span class="line">  -v /path/to/appdata/config:/config \</span><br><span class="line">  -v /lib/modules:/lib/modules \</span><br><span class="line">  --sysctl=&quot;net.ipv4.conf.all.src_valid_mark=1&quot; \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  linuxserver/wireguard</span><br></pre></td></tr></table></figure>

<p>内网跳板机：直接安装到宿主机</p>
<h3 id="Wireguard基本知识"><a href="#Wireguard基本知识" class="headerlink" title="Wireguard基本知识"></a>Wireguard基本知识</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#wireguard配置文件位置</span><br><span class="line">/etc/wireguard/</span><br><span class="line"></span><br><span class="line">默认配置文件/etc/wireguard/wg0.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用wg-quick 快速连接/断开 接口</span><br><span class="line">wg-quick up &lt;配置文件名&gt;</span><br><span class="line">wg-quick down &lt;配置文件名&gt;</span><br><span class="line"></span><br><span class="line">eg:wg-quick up wg0	//自动读取/etc/wireguard/wg0.conf，连接wg0接口</span><br><span class="line">eg:wg-quick up wg0	//会自动读取/etc/wireguard/wg0.conf，断开wg0接口</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#linuxserver/wireguard 此docker镜像支持使用命令行输出对应节点二维码，使用手机客户端扫码可以快速连接</span><br><span class="line">docker exec -it wireguard /app/show-peer 1 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker镜像中客户端的.conf配置文件目录</span><br><span class="line">/config</span><br></pre></td></tr></table></figure>

<p><img src="/posts/Wireguard-LANtoLAN/2.png"></p>
<h3 id="配置wireguard服务器端"><a href="#配置wireguard服务器端" class="headerlink" title="配置wireguard服务器端"></a>配置wireguard服务器端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/wireguard</span><br><span class="line"></span><br><span class="line">vi wg0.conf</span><br><span class="line">将下方红框中的内容填入AllowedIPs</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a><img src="/posts/Wireguard-LANtoLAN/3.png"></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#重启wireguard服务端</span><br><span class="line">wg-quick down wg0</span><br><span class="line">wg-quick up wg0</span><br></pre></td></tr></table></figure>

<h3 id="配置wireguard客户端"><a href="#配置wireguard客户端" class="headerlink" title="配置wireguard客户端"></a>配置wireguard客户端</h3><p>获取配置文件（在容器中进行操作）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /config/peer1</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">peer1.conf  peer1.png  privatekey-peer1  publickey-peer1</span><br><span class="line"></span><br><span class="line">vi peer1.conf</span><br></pre></td></tr></table></figure>

<p>复制屏幕上显示的内容，然后稍作修改<br><img src="/posts/Wireguard-LANtoLAN/4.png"><br>修改的地方是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">#配置客户端NAT，确保服务器可以访问客户端后面的网络</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">#修改客户端路由的IP段</span><br><span class="line">10.13.13.0/24,10.9.0.0/29</span><br><span class="line">#配置隧道保活时间</span><br><span class="line">PersistentKeepalive = 1</span><br></pre></td></tr></table></figure>

<p>修改后的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">Address = 10.13.13.2</span><br><span class="line">PrivateKey = *******************************</span><br><span class="line">ListenPort = 51820</span><br><span class="line">PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = *******************************</span><br><span class="line">Endpoint = **************:51820</span><br><span class="line">AllowedIPs = 10.13.13.0/24,10.9.0.0/29</span><br><span class="line">PersistentKeepalive = 1</span><br></pre></td></tr></table></figure>

<p>SSH连接上内网的跳板机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/wireguard</span><br><span class="line"></span><br><span class="line">vi wg0.conf</span><br><span class="line">然后将刚才编辑好的配置文件粘贴进去</span><br><span class="line"></span><br><span class="line">#开启内网客户端与服务器的连接</span><br><span class="line">wg-quick up wg0</span><br><span class="line"></span><br><span class="line">#测试能不能ping通服务器</span><br><span class="line">ping 10.13.13.1</span><br></pre></td></tr></table></figure>

<h3 id="测试服务端能否ping通客户端后的内网"><a href="#测试服务端能否ping通客户端后的内网" class="headerlink" title="测试服务端能否ping通客户端后的内网"></a>测试服务端能否ping通客户端后的内网</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 172.13.1.32</span><br><span class="line"></span><br><span class="line">root@62d21fb82751:/# ping 172.13.1.32</span><br><span class="line">PING 172.13.1.32 (172.13.1.32) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=1 ttl=124 time=50.1 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=2 ttl=124 time=55.8 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=3 ttl=124 time=52.8 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=4 ttl=124 time=50.7 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=5 ttl=124 time=50.1 ms</span><br><span class="line">--- 172.13.1.32 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4005ms</span><br><span class="line">rtt min/avg/max/mdev = 50.119/51.961/55.893/2.221 ms</span><br></pre></td></tr></table></figure>

<p>成功ping通</p>
<h3 id="使用nginx反代内网网站"><a href="#使用nginx反代内网网站" class="headerlink" title="使用nginx反代内网网站"></a>使用nginx反代内网网站</h3><p>因为客户端和服务器端都有172.17.0.0/16这条路由（docker bridge模式默认网段），可能会冲突。<br>我在portainer建立了一个新的docker网络，供wireguard服务端和nginx使用。<br><img src="/posts/Wireguard-LANtoLAN/5.png"><br>将刚才配置好的wireguard服务端移动到新建的网络中。<br>然后从dockerhub拉取nginx，新建容器。<br><img src="/posts/Wireguard-LANtoLAN/6.png"><br><img src="/posts/Wireguard-LANtoLAN/7.png"><br>给宿主机添加一条路由表，其中10.9.0.2是wireguard容器在docker网络中的一个内网地址，添加这条路由的作用是去172.13.1.32的数据包走wireguard进行转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add -net 172.13.1.32 netmask 255.255.255.255 gateway 10.9.0.2</span><br></pre></td></tr></table></figure>

<p>测试在宿主机ping172.13.1.32</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 172.13.1.32</span><br><span class="line"></span><br><span class="line">PING 172.13.1.32 (172.13.1.32) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=1 ttl=123 time=50.7 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=2 ttl=123 time=290 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=3 ttl=123 time=49.2 ms</span><br><span class="line">64 bytes from 172.13.1.32: icmp_seq=4 ttl=123 time=230 ms</span><br><span class="line">--- 172.13.1.32 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min/avg/max/mdev = 49.233/155.022/290.021/107.176 ms</span><br></pre></td></tr></table></figure>

<p>成功ping通<br>这下只需要配置nginx的反向代理了，因为宿主机都通网了，宿主机下面的容器去172.13.1.32就不用再做配置了<br>​</p>
<p>启动nginx容器，编辑配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>

<p>配置nginx反向代理<br><img src="/posts/Wireguard-LANtoLAN/8.png"><br>到这一步就配置完成了，可以访问ip对应的端口号进行测试查看有没有反代成功</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>VPN</tag>
        <tag>隧道</tag>
        <tag>Wireguard</tag>
        <tag>NGINX反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>黑群晖DSM6.2.3</title>
    <url>/posts/hackinto_synology/</url>
    <content><![CDATA[<h1 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h1><p>DSM6.2.3 系统引导有 DS3615，DS3617，DS918+ 三种，DS918 支持 UEFI 和 Legacy 启动，支持硬解码。DS3615 和 DS3617 只支持 Legacy 启动，不支持硬解码。</p>
<p>本例中选择的是DS918+。</p>
<h1 id="需要用到的文件"><a href="#需要用到的文件" class="headerlink" title="需要用到的文件"></a>需要用到的文件</h1><h2 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h2><ol>
<li>DS918+_6.23-25426-1.04b.img 引导文件，用于制作U盘引导</li>
<li>DS918+_6.23-25426.pat 系统文件，用于在WEB界面安装系统</li>
</ol>
<h2 id="会使用到的工具"><a href="#会使用到的工具" class="headerlink" title="会使用到的工具"></a>会使用到的工具</h2><p>ChipGenius——查看U盘VID PID</p>
<p>Win32DiskImager——写盘软件 将引导镜像写入U盘</p>
<p>DiskGenius Pro单文件版——格式化U盘、替换文件等</p>
<h2 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h2><p><a href="https://pan.yuukipix.com/%E9%BB%91%E7%BE%A4%E6%99%96">点我跳转</a></p>
<h1 id="制作U盘引导"><a href="#制作U盘引导" class="headerlink" title="制作U盘引导"></a>制作U盘引导</h1><ol>
<li><p>U盘插入电脑、使用DiskGenius删除U盘所有分区，然后点击左上角的<strong>保存更改</strong><br><img src="/posts/hackinto_synology/1.png"></p>
</li>
<li><p>打开ChipGenius查看U盘VID PID<br><img src="/posts/hackinto_synology/2.png"></p>
</li>
<li><p>关闭DiskGenius和ChipGenius软件，打开Win32DiskImager<br>选择写入的镜像和U盘（一定要确认无误后再写入）<br><img src="/posts/hackinto_synology/3.png"></p>
</li>
<li><p>关闭Win32DiskImager，重新打开DiskGenius，找到grub.cfg文件，复制到桌面<br><img src="/posts/hackinto_synology/4.png"></p>
</li>
<li><p>在桌面找到并打开grub.cfg，修改grub.cfg文件中的VID PID字段（前面的0x不需要动），如果要洗白才需替换SN MAC字段<br><img src="/posts/hackinto_synology/5.png"></p>
</li>
<li><p>把修改好的grub.cfg文件覆盖到U盘，替换掉原来的grub.cfg<br><img src="/posts/hackinto_synology/6.png"></p>
</li>
</ol>
<p>至此，U盘引导重做完成</p>
<h1 id="进行系统设置"><a href="#进行系统设置" class="headerlink" title="进行系统设置"></a>进行系统设置</h1><ol>
<li><p>刚才重做好引导的U盘插入黑群晖机器，通电开机</p>
</li>
<li><p>查找主机对应IP（下面给出3种方法）</p>
<ol>
<li>使用路由器后台（家庭用户）</li>
<li>使用find.synology.com（学生&amp;无法看到路由器后台用户，查找设备和被查找设备最好在同一个网段或者Vlan中成功率比较高）</li>
<li>端口扫描工具如nmap、zenmap扫描TCP 5000端口（扫整个网段）</li>
</ol>
</li>
<li><p>找到对应IP后使用浏览器访问即可看到设置页面</p>
<p><img src="/posts/hackinto_synology/7.png"></p>
</li>
<li><p>进行系统还原，此时选择<strong>手动上传</strong>前面提到的.pat系统文件</p>
</li>
<li><p>等待系统自动重启，重启后即可进入DSM桌面</p>
</li>
</ol>
<h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>如果重启后能看到WEB界面就代表成功了，现在开始体验一下系统吧！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>黑群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>解决公网云服务器青龙面板被爆破登录</title>
    <url>/posts/docker-qinglong/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>最近经常收到青龙面板的登陆失败提示，而且经常就是几十条推送过来，于是就想研究一下如何配置一下nginx来阻止盗cookie的嗨客通过ip加端口号的形式访问我的青龙面板。</p>
<p>也就是说青龙面板只能通过我绑定的域名+端口号访问，这样就大大减少了被脚本爆破的风险</p>
<p><strong>注意！本文中所有命令均在容器中执行！！！</strong></p>
<h3 id="配置青龙面板容器中的nginx配置文件"><a href="#配置青龙面板容器中的nginx配置文件" class="headerlink" title="配置青龙面板容器中的nginx配置文件"></a>配置青龙面板容器中的nginx配置文件</h3><p>我使用了portainer进行容器管理，通过网页进入青龙面板容器的console</p>
<p><img src="/posts/docker-qinglong/1.png"></p>
<p><img src="/posts/docker-qinglong/2.png"></p>
<p>使用vim编辑nginx的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/conf.d/front.conf</span><br></pre></td></tr></table></figure>

<p>需要添加的地方，加上这个配置后使用ip+端口号访问就会提示404</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 5700 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/docker-qinglong/3.png"></p>
<h3 id="验证配置文件并重启nginx"><a href="#验证配置文件并重启nginx" class="headerlink" title="验证配置文件并重启nginx"></a>验证配置文件并重启nginx</h3><h4 id="验证配置文件"><a href="#验证配置文件" class="headerlink" title="验证配置文件"></a>验证配置文件</h4><p>在容器的console中执行命令，验证配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>如果出现successful则表示修改的配置文件没问题</p>
<p><img src="/posts/docker-qinglong/4.png"></p>
<h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><p>在容器的console中执行命令，重启nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>使用ip+端口号访问提示404</p>
<p><img src="/posts/docker-qinglong/5.png"></p>
<p>使用域名+端口号访问则正常</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然这样可以防止5700端口被爆破，但是这样配置起来也挺麻烦，配置完后重启容器配置还会清空，如果能直接修改青龙面板的映射端口是更优解。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>Docker</tag>
        <tag>云服务器</tag>
        <tag>薅羊毛</tag>
        <tag>青龙面板</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Linux云服务器异常修复</title>
    <url>/posts/linuxserver-fix/</url>
    <content><![CDATA[<h1 id="异常表现"><a href="#异常表现" class="headerlink" title="异常表现"></a>异常表现</h1><p>手贱恢复过一次快照后，发现docker无法启动<br>服务器中所有服务都基于docker搭建，所以恢复docker功能就能解决问题</p>
<h1 id="尝试排查并解决问题"><a href="#尝试排查并解决问题" class="headerlink" title="尝试排查并解决问题"></a>尝试排查并解决问题</h1><p>尝试重启docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>系统提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Job for docker.service failed because the control process exited with error code.</span><br><span class="line">See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>

<p>根据提示输入命令查看报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# systemctl status docker.service</span><br><span class="line"></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Thu 2022-02-03 00:55:32 CST; 54s ago</span><br><span class="line">TriggeredBy: ● docker.socket</span><br><span class="line">       Docs: https://docs.docker.com</span><br><span class="line">    Process: 340597 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)</span><br><span class="line">   Main PID: 340597 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Feb 03 00:55:30 VM-8-10-ubuntu systemd[1]: docker.service: Main process exited, code=exited, status=1/FAILURE</span><br><span class="line">Feb 03 00:55:30 VM-8-10-ubuntu systemd[1]: docker.service: Failed with result &#x27;exit-code&#x27;.</span><br><span class="line">Feb 03 00:55:30 VM-8-10-ubuntu systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">Feb 03 00:55:32 VM-8-10-ubuntu systemd[1]: docker.service: Scheduled restart job, restart counter is at 3.</span><br><span class="line">Feb 03 00:55:32 VM-8-10-ubuntu systemd[1]: Stopped Docker Application Container Engine.</span><br><span class="line">Feb 03 00:55:32 VM-8-10-ubuntu systemd[1]: docker.service: Start request repeated too quickly.</span><br><span class="line">Feb 03 00:55:32 VM-8-10-ubuntu systemd[1]: docker.service: Failed with result &#x27;exit-code&#x27;.</span><br><span class="line">Feb 03 00:55:32 VM-8-10-ubuntu systemd[1]: Failed to start Docker Application Container Engine.</span><br></pre></td></tr></table></figure>

<p>看不出什么有用信息，继续排查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@:~# dockerd --debug</span><br><span class="line"></span><br><span class="line">INFO[2022-02-03T00:57:30.200810403+08:00] Starting up</span><br><span class="line">DEBU[2022-02-03T00:57:30.201601472+08:00] Listener created for HTTP on unix (/var/run/docker.sock)</span><br><span class="line">INFO[2022-02-03T00:57:30.203362974+08:00] detected 127.0.0.53 nameserver, assuming systemd-resolved, so using resolv.conf: /run/systemd/resolve/resolv.conf</span><br><span class="line">DEBU[2022-02-03T00:57:30.203766518+08:00] Golang&#x27;s threads limit set to 13590</span><br><span class="line">INFO[2022-02-03T00:57:30.204089641+08:00] parsed scheme: &quot;unix&quot;                         module=grpc</span><br><span class="line">INFO[2022-02-03T00:57:30.204159640+08:00] scheme &quot;unix&quot; not registered, fallback to default scheme  module=grpc</span><br><span class="line">INFO[2022-02-03T00:57:30.204224276+08:00] ccResolverWrapper: sending update to cc: &#123;[&#123;unix:///run/containerd/containerd.sock  &lt;nil&gt; 0 &lt;nil&gt;&#125;] &lt;nil&gt; &lt;nil&gt;&#125;  module=grpc</span><br><span class="line">INFO[2022-02-03T00:57:30.204282462+08:00] ClientConn switching balancer to &quot;pick_first&quot;  module=grpc</span><br><span class="line">DEBU[2022-02-03T00:57:30.204722973+08:00] metrics API listening on /var/run/docker/metrics.sock</span><br><span class="line">INFO[2022-02-03T00:57:30.205634189+08:00] parsed scheme: &quot;unix&quot;                         module=grpc</span><br><span class="line">INFO[2022-02-03T00:57:30.205706673+08:00] scheme &quot;unix&quot; not registered, fallback to default scheme  module=grpc</span><br><span class="line">INFO[2022-02-03T00:57:30.205760302+08:00] ccResolverWrapper: sending update to cc: &#123;[&#123;unix:///run/containerd/containerd.sock  &lt;nil&gt; 0 &lt;nil&gt;&#125;] &lt;nil&gt; &lt;nil&gt;&#125;  module=grpc</span><br><span class="line">INFO[2022-02-03T00:57:30.205810825+08:00] ClientConn switching balancer to &quot;pick_first&quot;  module=grpc</span><br><span class="line">DEBU[2022-02-03T00:57:30.207611945+08:00] Using default logging driver json-file</span><br><span class="line">DEBU[2022-02-03T00:57:30.207775882+08:00] [graphdriver] priority list: [btrfs zfs overlay2 fuse-overlayfs aufs overlay devicemapper vfs]</span><br><span class="line">DEBU[2022-02-03T00:57:30.222527765+08:00] processing event stream                       module=libcontainerd namespace=plugins.moby</span><br><span class="line">DEBU[2022-02-03T00:57:30.250229294+08:00] backingFs=extfs, projectQuotaSupported=false, indexOff=&quot;index=off,&quot;, userxattr=&quot;&quot;  storage-driver=overlay2</span><br><span class="line">INFO[2022-02-03T00:57:30.250411749+08:00] [graphdriver] using prior storage driver: overlay2</span><br><span class="line">DEBU[2022-02-03T00:57:30.250511448+08:00] Initialized graph driver overlay2</span><br><span class="line">DEBU[2022-02-03T00:57:30.258155291+08:00] No quota support for local volumes in /var/lib/docker/volumes: Filesystem does not support, or has not enabled quotas</span><br><span class="line">WARN[2022-02-03T00:57:30.262367778+08:00] Your kernel does not support swap memory limit</span><br><span class="line">WARN[2022-02-03T00:57:30.262458822+08:00] Your kernel does not support CPU realtime scheduler</span><br><span class="line">WARN[2022-02-03T00:57:30.262516430+08:00] Your kernel does not support cgroup blkio weight</span><br><span class="line">WARN[2022-02-03T00:57:30.262560163+08:00] Your kernel does not support cgroup blkio weight_device</span><br><span class="line">DEBU[2022-02-03T00:57:30.262722171+08:00] Max Concurrent Downloads: 3</span><br><span class="line">DEBU[2022-02-03T00:57:30.262773010+08:00] Max Concurrent Uploads: 5</span><br><span class="line">DEBU[2022-02-03T00:57:30.262811831+08:00] Max Download Attempts: 5</span><br><span class="line">INFO[2022-02-03T00:57:30.262858770+08:00] Loading containers: start.</span><br><span class="line">DEBU[2022-02-03T00:57:30.264578215+08:00] loaded container                              container=f499cddf6d78870b4b9ba422ed1d4425997aee52a06ae99a666e2d7ebcd0debe paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.264733549+08:00] processing event stream                       module=libcontainerd namespace=moby</span><br><span class="line">DEBU[2022-02-03T00:57:30.265684915+08:00] loaded container                              container=08e5723d475b2ee8754bb85f4a7f47c41c0dc602a531460c4b77e6374a76fd8d paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.267811775+08:00] loaded container                              container=257d39cf15997dc2f103caa60954d3927e232aec92a55394985557cd49e95ecc paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.268752637+08:00] loaded container                              container=31520944f8906861f7d0340a5da962ceeee0e8a86d8aff5e5f1e4e4ef090b650 paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.269713929+08:00] loaded container                              container=34a84057691d8e1f25755e95842db66bcb21b1a9572ba45e33e208fcd6ea37d5 paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.270763037+08:00] loaded container                              container=5db4bfe59ba15b1aee101f6791c492e8fc446f11bace9e586f52743e98047b1f paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.271726087+08:00] loaded container                              container=6537ce5ae3688ee750adc2d9f157992b839f702a2c5b7b68b9e1fc93890c802b paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.272652297+08:00] loaded container                              container=c25097579654e457933453beb54036e1a4793cb7d28690d798b6ca06c7c81f93 paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.273613863+08:00] loaded container                              container=eda43d1d856fa4ea74df84bb7f05f782d7591a680c38213974a756055eb68f2c paused=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.328623040+08:00] restoring container                           container=6537ce5ae3688ee750adc2d9f157992b839f702a2c5b7b68b9e1fc93890c802b paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.334741870+08:00] restoring container                           container=08e5723d475b2ee8754bb85f4a7f47c41c0dc602a531460c4b77e6374a76fd8d paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.343438756+08:00] restoring container                           container=34a84057691d8e1f25755e95842db66bcb21b1a9572ba45e33e208fcd6ea37d5 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.352181053+08:00] restoring container                           container=c25097579654e457933453beb54036e1a4793cb7d28690d798b6ca06c7c81f93 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.360048134+08:00] restoring container                           container=eda43d1d856fa4ea74df84bb7f05f782d7591a680c38213974a756055eb68f2c paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.366867825+08:00] restoring container                           container=f499cddf6d78870b4b9ba422ed1d4425997aee52a06ae99a666e2d7ebcd0debe paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.372067287+08:00] restoring container                           container=257d39cf15997dc2f103caa60954d3927e232aec92a55394985557cd49e95ecc paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.377909875+08:00] restoring container                           container=31520944f8906861f7d0340a5da962ceeee0e8a86d8aff5e5f1e4e4ef090b650 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.383392799+08:00] restoring container                           container=5db4bfe59ba15b1aee101f6791c492e8fc446f11bace9e586f52743e98047b1f paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384322666+08:00] alive: false                                  container=31520944f8906861f7d0340a5da962ceeee0e8a86d8aff5e5f1e4e4ef090b650 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384411496+08:00] done restoring container                      container=31520944f8906861f7d0340a5da962ceeee0e8a86d8aff5e5f1e4e4ef090b650 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384497364+08:00] alive: false                                  container=5db4bfe59ba15b1aee101f6791c492e8fc446f11bace9e586f52743e98047b1f paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384514082+08:00] done restoring container                      container=5db4bfe59ba15b1aee101f6791c492e8fc446f11bace9e586f52743e98047b1f paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384536982+08:00] alive: false                                  container=6537ce5ae3688ee750adc2d9f157992b839f702a2c5b7b68b9e1fc93890c802b paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384589149+08:00] done restoring container                      container=6537ce5ae3688ee750adc2d9f157992b839f702a2c5b7b68b9e1fc93890c802b paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384612486+08:00] alive: false                                  container=08e5723d475b2ee8754bb85f4a7f47c41c0dc602a531460c4b77e6374a76fd8d paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384648980+08:00] done restoring container                      container=08e5723d475b2ee8754bb85f4a7f47c41c0dc602a531460c4b77e6374a76fd8d paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384672572+08:00] alive: false                                  container=34a84057691d8e1f25755e95842db66bcb21b1a9572ba45e33e208fcd6ea37d5 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384709004+08:00] done restoring container                      container=34a84057691d8e1f25755e95842db66bcb21b1a9572ba45e33e208fcd6ea37d5 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384749849+08:00] alive: false                                  container=c25097579654e457933453beb54036e1a4793cb7d28690d798b6ca06c7c81f93 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384782402+08:00] done restoring container                      container=c25097579654e457933453beb54036e1a4793cb7d28690d798b6ca06c7c81f93 paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384831815+08:00] alive: false                                  container=eda43d1d856fa4ea74df84bb7f05f782d7591a680c38213974a756055eb68f2c paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384844843+08:00] done restoring container                      container=eda43d1d856fa4ea74df84bb7f05f782d7591a680c38213974a756055eb68f2c paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384889707+08:00] alive: false                                  container=f499cddf6d78870b4b9ba422ed1d4425997aee52a06ae99a666e2d7ebcd0debe paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384924570+08:00] done restoring container                      container=f499cddf6d78870b4b9ba422ed1d4425997aee52a06ae99a666e2d7ebcd0debe paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.384978063+08:00] alive: false                                  container=257d39cf15997dc2f103caa60954d3927e232aec92a55394985557cd49e95ecc paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.385011841+08:00] done restoring container                      container=257d39cf15997dc2f103caa60954d3927e232aec92a55394985557cd49e95ecc paused=false restarting=false running=false</span><br><span class="line">DEBU[2022-02-03T00:57:30.385058226+08:00] Option Experimental: false</span><br><span class="line">DEBU[2022-02-03T00:57:30.385095290+08:00] Option DefaultDriver: bridge</span><br><span class="line">DEBU[2022-02-03T00:57:30.385103316+08:00] Option DefaultNetwork: bridge</span><br><span class="line">DEBU[2022-02-03T00:57:30.385135579+08:00] Network Control Plane MTU: 1500</span><br><span class="line">WARN[2022-02-03T00:57:30.387074890+08:00] Running modprobe bridge br_netfilter failed with message: modprobe: WARNING: Module br_netfilter not found in directory /lib/modules/5.4.0-77-generic</span><br><span class="line">, error: exit status 1</span><br><span class="line">WARN[2022-02-03T00:57:30.391436976+08:00] Running iptables --wait -t nat -L -n failed with message: `modprobe: FATAL: Module ip_tables not found in directory /lib/modules/5.4.0-77-generic</span><br><span class="line">iptables v1.8.4 (legacy): can&#x27;t initialize iptables table `nat&#x27;: Table does not exist (do you need to insmod?)</span><br><span class="line">Perhaps iptables or your kernel needs to be upgraded.`, error: exit status 3</span><br><span class="line">DEBU[2022-02-03T00:57:30.397357303+08:00] /usr/sbin/iptables, [-t filter -C FORWARD -j DOCKER-ISOLATION]</span><br><span class="line">DEBU[2022-02-03T00:57:30.400690467+08:00] /usr/sbin/iptables, [-t nat -D PREROUTING -m addrtype --dst-type LOCAL -j DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.411769946+08:00] /usr/sbin/iptables, [-t nat -D OUTPUT -m addrtype --dst-type LOCAL ! --dst 127.0.0.0/8 -j DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.423060451+08:00] /usr/sbin/iptables, [-t nat -D OUTPUT -m addrtype --dst-type LOCAL -j DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.434681947+08:00] /usr/sbin/iptables, [-t nat -D PREROUTING]</span><br><span class="line">DEBU[2022-02-03T00:57:30.438556532+08:00] /usr/sbin/iptables, [-t nat -D OUTPUT]</span><br><span class="line">DEBU[2022-02-03T00:57:30.442091291+08:00] /usr/sbin/iptables, [-t nat -F DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.445419314+08:00] /usr/sbin/iptables, [-t nat -X DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.448885727+08:00] /usr/sbin/iptables, [-t filter -F DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.452328114+08:00] /usr/sbin/iptables, [-t filter -X DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.456372710+08:00] /usr/sbin/iptables, [-t filter -F DOCKER-ISOLATION-STAGE-1]</span><br><span class="line">DEBU[2022-02-03T00:57:30.459847434+08:00] /usr/sbin/iptables, [-t filter -X DOCKER-ISOLATION-STAGE-1]</span><br><span class="line">DEBU[2022-02-03T00:57:30.463195322+08:00] /usr/sbin/iptables, [-t filter -F DOCKER-ISOLATION-STAGE-2]</span><br><span class="line">DEBU[2022-02-03T00:57:30.466640713+08:00] /usr/sbin/iptables, [-t filter -X DOCKER-ISOLATION-STAGE-2]</span><br><span class="line">DEBU[2022-02-03T00:57:30.469992937+08:00] /usr/sbin/iptables, [-t filter -F DOCKER-ISOLATION]</span><br><span class="line">DEBU[2022-02-03T00:57:30.473415734+08:00] /usr/sbin/iptables, [-t filter -X DOCKER-ISOLATION]</span><br><span class="line">DEBU[2022-02-03T00:57:30.476868678+08:00] /usr/sbin/iptables, [-t nat -n -L DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.480249405+08:00] /usr/sbin/iptables, [-t nat -N DOCKER]</span><br><span class="line">DEBU[2022-02-03T00:57:30.483645172+08:00] daemon configured with a 15 seconds minimum shutdown timeout</span><br><span class="line">DEBU[2022-02-03T00:57:30.483731011+08:00] start clean shutdown of all containers with a 15 seconds timeout...</span><br><span class="line">DEBU[2022-02-03T00:57:30.484045148+08:00] found 0 orphan layers</span><br><span class="line">DEBU[2022-02-03T00:57:30.484360428+08:00] Cleaning up old mountid : start.</span><br><span class="line">DEBU[2022-02-03T00:57:30.484570389+08:00] Cleaning up old mountid : done.</span><br><span class="line">failed to start daemon: Error initializing network controller: error obtaining controller instance: failed to create NAT chain DOCKER: iptables failed: iptables -t nat -N DOCKER: modprobe: FATAL: Module ip_tables not found in directory /lib/modules/5.4.0-77-generic</span><br><span class="line">iptables v1.8.4 (legacy): can&#x27;t initialize iptables table `nat&#x27;: Table does not exist (do you need to insmod?)</span><br><span class="line">Perhaps iptables or your kernel needs to be upgraded.</span><br><span class="line"> (exit status 3)</span><br></pre></td></tr></table></figure>

<p>看到日志提示”iptables”报错，尝试排查iptables</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# iptables --list</span><br><span class="line">modprobe: FATAL: Module ip_tables not found in directory /lib/modules/5.4.0-77-generic</span><br><span class="line">iptables v1.8.4 (legacy): can&#x27;t initialize iptables table `filter&#x27;: Table does not exist (do you need to insmod?)</span><br><span class="line">Perhaps iptables or your kernel needs to be upgraded.</span><br></pre></td></tr></table></figure>

<p>看到这里意识到不对劲，可能备份快照的时候损坏了系统？难道是内核出问题了？不过还是不死心，尝试更新系统软件包看看能不能重新启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update		#刷新存储库索引</span><br><span class="line">apt upgrade		#更新系统软件包</span><br></pre></td></tr></table></figure>

<p>检查到这里，我觉得我可能没办法修好它了，不过好在这是云服务器，可以重置镜像。</p>
<h1 id="备份Docker相关文件"><a href="#备份Docker相关文件" class="headerlink" title="备份Docker相关文件"></a>备份Docker相关文件</h1><p>使用tar命令备份我映射的Docker文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf docker.tar /docker</span><br></pre></td></tr></table></figure>

<p>使用tar文件备份Docker 镜像和容器的存储路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zcvf docker.tar.gz /var/lib/docker</span><br></pre></td></tr></table></figure>

<p>使用SFTP工具将备份文件拷贝到本地<br>参考：</p>
<h1 id="重新部署服务器"><a href="#重新部署服务器" class="headerlink" title="重新部署服务器"></a>重新部署服务器</h1><p>进入控制台重置镜像<br>​</p>
<p>重新安装docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure>

<p>附：apt命令（尽量使用apt而不是apt-get）</p>
<table>
<thead>
<tr>
<th>apt 命令</th>
<th>取代的命令</th>
<th>命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td>apt install</td>
<td>apt-get install</td>
<td>安装软件包</td>
</tr>
<tr>
<td>apt remove</td>
<td>apt-get remove</td>
<td>移除软件包</td>
</tr>
<tr>
<td>apt purge</td>
<td>apt-get purge</td>
<td>移除软件包及配置文件</td>
</tr>
<tr>
<td>apt update</td>
<td>apt-get update</td>
<td>刷新存储库索引</td>
</tr>
<tr>
<td>apt upgrade</td>
<td>apt-get upgrade</td>
<td>升级所有可升级的软件包</td>
</tr>
<tr>
<td>apt autoremove</td>
<td>apt-get autoremove</td>
<td>自动删除不需要的包</td>
</tr>
<tr>
<td>apt full-upgrade</td>
<td>apt-get dist-upgrade</td>
<td>在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td>apt search</td>
<td>apt-cache search</td>
<td>搜索应用程序</td>
</tr>
<tr>
<td>apt show</td>
<td>apt-cache show</td>
<td>显示装细节</td>
</tr>
</tbody></table>
<p>复制刚才备份的文件到服务器，并解压到原来位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf docker.tar</span><br><span class="line">tar -zxvf docker.tar.gz </span><br></pre></td></tr></table></figure>

<p>恢复好文件后，reboot重启主机<br>开机之后使用docker ps查看容器列表，发现之前的容器都回来了<br>​</p>
<p>服务器基本修复了，但是因为重新启动的原因，docker的bridge网络下容器的IP会有所变化，可能某些细节需要一点点时间修复。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>翻车</tag>
      </tags>
  </entry>
  <entry>
    <title>socks5&amp;http_proxy代理</title>
    <url>/posts/socks5&amp;http_proxy/</url>
    <content><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zgao.top/%E5%A5%87%E5%AE%89%E4%BF%A1%E5%AE%9E%E4%B9%A0%E4%BA%94-socks5%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/">《奇安信实习(五)-Socks5协议抓包分析》</a><br><a href="https://reezon.github.io/2018/05/23/%E5%85%B3%E4%BA%8Ess(%E9%85%B8%E9%85%B8)%E5%92%8Cssr(%E9%85%B8%E9%85%B8%E4%B9%B3)%EF%BC%8C%E8%BF%98%E6%9C%89vpn%E5%92%8Csocks5/">《关于ss(酸酸)和ssr(酸酸乳)，还有vpn和socks5》</a></p>
<h2 id="Socks5-代理"><a href="#Socks5-代理" class="headerlink" title="Socks5 代理"></a>Socks5 代理</h2><ul>
<li>socks(socket security)是一种网络传输协议，它工作在OSI七层模型中的第五层/会话层。</li>
<li>socks5比socks4协议多了验证、IPv6、UDP支持。</li>
<li>socks5代理是把你的网络数据由代理服务器转发到目的地，这个过程中你是没有一条专用通道的，只是数据包的发出，然后被代理服务器收到，然后代理服务器再进行转发，整个过程并没有额外的处理。</li>
<li>socks5 协议并不负责代理服务器的数据传输环节，此协议只是在Client/Server两端真实交互之间，建立起一条从客户端到代理服务器的授信连接。</li>
</ul>
<h2 id="Socks5和VPN的区别"><a href="#Socks5和VPN的区别" class="headerlink" title="Socks5和VPN的区别"></a>Socks5和VPN的区别</h2><ul>
<li>vpn是建立一条静态路由0.0.0.0/0，所有的应用都走这条路出去。</li>
<li>vpn会给你分配一个内网地址（例如L2TP、PPTP），socks5不会。</li>
<li>vpn不需要配置端口号，socks5需要。</li>
</ul>
<h2 id="Socks5的交互方式"><a href="#Socks5的交互方式" class="headerlink" title="Socks5的交互方式"></a>Socks5的交互方式</h2><p>socks5  是一个Client/Server交互的协议，交互大概分为这么几步：</p>
<ol>
<li>客户端发送认证协商</li>
<li>代理服务器就认证协商进行回复（如拒绝则本次会话结束）<ol>
<li>如需GSSAPI或用户名/密码认证，客户端发送认证信息</li>
<li>代理服务器就对应项进行鉴权，并进行回复或拒绝</li>
</ol>
</li>
<li>客户端发送希望连接的目标信息</li>
<li>代理服务器就连接信息进行确认或拒绝</li>
<li>【非协议内容】：代理服务器连接目标并 pipe 到客户端Socks5协议并不负责代理服务器的数据传输环节，此协议只是在C/S两端真实交互之间，建立起一条从客户端到代理服务器的授信连接</li>
</ol>
<h2 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h2><p>HTTP代理工作在OSI七层模型中的第七层/应用层。HTTP代理客户机的HTTP(S)访问，主要代理浏览器访问网页。</p>
<h2 id="socks5和HTTP代理的对比"><a href="#socks5和HTTP代理的对比" class="headerlink" title="socks5和HTTP代理的对比"></a>socks5和HTTP代理的对比</h2><ul>
<li>socks5工作在比HTTP代理更低的层次</li>
<li>socks5使用握手协议来通知代理软件其客户端试图进行的socks连接，然后尽可能透明地进行操作（不对请求或响应进行修改），而HTTP代理可能会解释和重写报头</li>
<li>socks5代理支持UDP协议，而HTTP代理不能</li>
</ul>
<h2 id="网络示意图"><a href="#网络示意图" class="headerlink" title="网络示意图"></a>网络示意图</h2><p><img src="socks5&http_proxy/1.png"></p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>搭建socks5和HTTP代理（Clash Docker版）</p>
<p>代理：Socks5代理（IP：172.16.7.233:7891）HTTP代理（IP：172.16.7.233:7890）<br>目标网站：<a href="http://172.16.3.9/backend/getIP.php">http://172.16.3.9/backend/getIP.php</a>（可返回访问者IP）</p>
<p>软件环境：Win10系统电脑、SSTAP、WireShark、CURL<br>​</p>
<p>流量路径：本机浏览器–&gt;HTTP代理（如果有）–&gt;SSTAP虚拟网卡–&gt;物理网卡–&gt;socks代理服务器–&gt;HTTP代理服务器（如果有）<br>​</p>
<p>流量分析：使用WireShark在<strong>物理网卡</strong>接口上抓取流量进行分析<br>注意：默认情况下，只有socks代理的端口设置为1080时，wireshark才能识别为socks协议的流量。</p>
<p>Q：为什么选择SSATP作为代理客户端软件？<br>A：因为SSTAP使用的代理模式是利用虚拟网卡技术在网络层实现的代理工具，所有流量都会被转到虚拟网卡上，这样方便分析所有流量。<br>​</p>
<p>Q：为什么使用Clash作为代理服务端？<br>A：因为Clash自带HTTP和Socks5代理，简单配置一下就能用。</p>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>Socks5代理可以设置密码认证，但是认证时客户端发给服务端的账号密码走TCP协议进行明文传输。</p>
<h3 id="无Socks5代理-无HTTP代理"><a href="#无Socks5代理-无HTTP代理" class="headerlink" title="无Socks5代理 无HTTP代理"></a>无Socks5代理 无HTTP代理</h3><p><img src="socks5&http_proxy/2.png"><br>此时目标网站返回的IP为我的真实IP。</p>
<h3 id="开启Socks5代理-无HTTP代理"><a href="#开启Socks5代理-无HTTP代理" class="headerlink" title="开启Socks5代理 无HTTP代理"></a>开启Socks5代理 无HTTP代理</h3><p>curl设置socks5代理方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &lt;要访问的地址&gt; --socks5 &lt;host[:port]&gt; --proxy-user &lt;user:password&gt;</span><br></pre></td></tr></table></figure>

<p><img src="socks5&http_proxy/3.png"></p>
<p><img src="socks5&http_proxy/4.png"></p>
<p>可以看到目标网站返回的IP是我Socks代理的IP，但是我抓到的包中可以看到我的认证账号密码是以明文传输的。<br>密码只由socks服务端用来鉴定客户端是否有权连接，并不用密码对传输的信息进行加密。<br>在TCP三次握手后，建立socks连接，有着极为明显的流量特征（主要体现在TCP报文中的字节流中)。</p>
<h3 id="开启HTTP代理无socks5代理"><a href="#开启HTTP代理无socks5代理" class="headerlink" title="开启HTTP代理无socks5代理"></a>开启HTTP代理无socks5代理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &lt;要访问的地址&gt; -x &lt;host[:port]&gt; --proxy-user &lt;user:password&gt;</span><br></pre></td></tr></table></figure>

<p><img src="socks5&http_proxy/5.png"></p>
<p>仔细看报文，使用HTTP代理时发送的HTTP报文（上图序号4的数据包)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://172.16.3.9/backend/getIP.php</span><br></pre></td></tr></table></figure>

<p>而使用socks代理时，发出的HTTP报文是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /backend/getIP.php</span><br></pre></td></tr></table></figure>

<p>除此之外，使用HTTP代理时，如果设置了认证，那么在发出HTTP报文的时候会有一个专门的字段Proxy-Authorization来发送账号密码。<br><img src="socks5&http_proxy/6.png"></p>
<h3 id="开启HTTP代理并开启Socks5代理"><a href="#开启HTTP代理并开启Socks5代理" class="headerlink" title="开启HTTP代理并开启Socks5代理"></a>开启HTTP代理并开启Socks5代理</h3><p>此时开启SSTAP代理本机所有流量到socks代理服务器<br><img src="socks5&http_proxy/7.png"><br>CURL设置HTTP代理<br>WireShark开启抓包<br><img src="socks5&http_proxy/8.png"><br>虽然返回结果是我的代理服务器的IP（我的HTTP和socks代理的IP地址一样），但是实际上流量是走HTTP代理过了一遍。如果HTTP和SOCKS代理为不同IP，则会返回HTTP代理的IP。<br><img src="socks5&http_proxy/9.png"><br>上图物理网卡出口抓到的HTTP报文，和上面的仅使用HTTP代理方式发出的报文一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Socks是个很实用的代理协议，但是在连接建立时、传输流量过程中有着极为明显的流量特征。<br>流量加密、反检测、免杀：</p>
<ul>
<li>Socks5+HTTP代理并不会让本来明文传输的浏览加密，但是可以改变请求的IP，服务器看到访问者的IP就是你的代理代理服务器的IP。</li>
<li>如果流量本身没有加密，实战中流控设备很容易识别到客户端连接成功的流量规则。</li>
<li>如果想要加密Socks5的流量，则需要安装魔改版Socks服务端和客户端，比如著名的SS/SSR就是用Socks5来实现的，Cobalt Strike也有相关插件对流量进行加密。</li>
</ul>
<p>可代理的流量：</p>
<ul>
<li>因为HTTP代理工作在应用层，仅能代理HTTP/HTTPS流量，故不能代理SSH或远程桌面等流量，</li>
<li>Socks5则可以代理SSH和远程桌面，但是不走TCP/UDP协议的流量（如ICMP、ARP等）则不能代理</li>
</ul>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>VPN</tag>
        <tag>隧道</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>静态托管Blog:Hexo+Github Pages+个人域名+CDN</title>
    <url>/posts/myblog/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为什么要使用这套方案？<br>使用这套方案成本更低，无需担心服务器被攻击，无需维护服务器，也不用担心服务器到期。</p>
<p>国内购买的域名无需备案就能使用别名解析到Github Pages服务器，但使用国内的CDN服务需要备案。</p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>由于我事先已经安装，所以仅留下Git下载地址</p>
<p><a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>前往<a href="https://nodejs.org/zh-cn/">nodejs.org</a>下载并安装长期维护版</p>
<h3 id="使用npm安装Hexo（全局安装）"><a href="#使用npm安装Hexo（全局安装）" class="headerlink" title="使用npm安装Hexo（全局安装）"></a>使用npm安装Hexo（全局安装）</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>

<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<ol>
<li><code>npx hexo &lt;command&gt;</code></li>
<li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code></li>
</ol>
<h2 id="开始写博客"><a href="#开始写博客" class="headerlink" title="开始写博客"></a>开始写博客</h2><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>使用以下命令初始化Hexo ，会在&lt;folder&gt;中新建所需要的文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第一篇Blog"><a href="#第一篇Blog" class="headerlink" title="第一篇Blog"></a>第一篇Blog</h3><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>使用以下命令新建一篇博客</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo new &lt;文章名&gt;</span><br></pre></td></tr></table></figure>

<p>这时候就能在</p>
<p>./Hexo/source/_posts目录下看到刚才建立的文章的markdown文件</p>
<h4 id="本地开启server查看文章"><a href="#本地开启server查看文章" class="headerlink" title="本地开启server查看文章"></a>本地开启server查看文章</h4><p>使用以下命令生成静态文件，并开启本地Web服务器查看效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo clean	//删除生成的文件和缓存</span><br><span class="line">npx hexo generate	//生成静态文件</span><br><span class="line">npx hexo server	//启动本地Web服务器</span><br></pre></td></tr></table></figure>

<p>上传文章到Gitpage</p>
<p>可使用以下命令上传到Gitpage，不过在此之前需要对./Hexo目录下的**_config.yml**进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: &lt;你的gitpage地址&gt;</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;你的gitpage地址&gt;</span><br><span class="line">  branch: master	//要特别说明一下上传的分支，github创建的gitpage默认使用main分支，需要在仓库的gitpage相关设置更改分支为master分支，或者干脆直接上传到main分支里面</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure>

<p>如果之前没有配置git，还需配置git，网上教程比较多，不再赘述。</p>
<h3 id="图片无法显示踩坑"><a href="#图片无法显示踩坑" class="headerlink" title="图片无法显示踩坑"></a>图片无法显示踩坑</h3><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="安装hexo-asset-image修改版插件"><a href="#安装hexo-asset-image修改版插件" class="headerlink" title="安装hexo-asset-image修改版插件"></a>安装hexo-asset-image修改版插件</h5><p><a href="https://github.com/xcodebuild/hexo-asset-image">https://github.com/xcodebuild/hexo-asset-image</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/xcodebuild/hexo<span class="literal">-asset</span><span class="literal">-image</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<h5 id="开启post-asset-folder"><a href="#开启post-asset-folder" class="headerlink" title="开启post_asset_folder"></a>开启post_asset_folder</h5><p>关于post_asset_folder，官方文档这样描述：</p>
<blockquote>
<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
</blockquote>
<p>编辑<strong>Hexo根目录</strong>下的**_config.yml**</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h4><p>使用以下命令新建一篇文章，将会在 *<em>source\_posts\*</em> 目录下生成 <strong>new_blog.md</strong> 和 <strong>new_blog文件夹</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo new <span class="string">&quot;new_blog&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<strong>new_blog.md</strong>中<strong>使用相对路径</strong>引用<strong>new_blog文件夹</strong>下的1.jpg</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](Blog\1.jpg)</span><br></pre></td></tr></table></figure>

<p>清空Hexo缓存，重新编译后开启本地web测试效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npx hexo clean</span><br><span class="line">npx hexo generate</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>

<p>本地web可正常显示，图片路径一切正常</p>
<p><img src="/posts/myblog/1.png" alt="测试正常"></p>
<h2 id="将博客托管到Github-Pages"><a href="#将博客托管到Github-Pages" class="headerlink" title="将博客托管到Github Pages"></a>将博客托管到Github Pages</h2><h3 id="在Github中新建仓库"><a href="#在Github中新建仓库" class="headerlink" title="在Github中新建仓库"></a>在Github中新建仓库</h3><p>注意：命名需以【你希望的名字】.github.io命名</p>
<p>后续就可以使用这个地址进行访问，比如我的就是</p>
<p><img src="/posts/myblog/2.png"></p>
<h3 id="在仓库中启用Github-Pages"><a href="#在仓库中启用Github-Pages" class="headerlink" title="在仓库中启用Github Pages"></a>在仓库中启用Github Pages</h3><p>进入刚才建立仓库的设置，找到pages相关选项</p>
<p><img src="/posts/myblog/3.png"></p>
<p><img src="/posts/myblog/4.png"></p>
<p>然后根据提示开启Github Pages即可</p>
<h3 id="使用npx-hexo-deploy上传博客文件到Github仓库"><a href="#使用npx-hexo-deploy上传博客文件到Github仓库" class="headerlink" title="使用npx hexo -deploy上传博客文件到Github仓库"></a>使用npx hexo -deploy上传博客文件到Github仓库</h3><h4 id="编辑Hexo配置文件"><a href="#编辑Hexo配置文件" class="headerlink" title="编辑Hexo配置文件"></a>编辑Hexo配置文件</h4><p>找到Hexo安装目录下的_config.yml文件<br>找到deploy这一项，修改rebo为你刚才创建仓库的地址</p>
<p><img src="/posts/myblog/5.png"></p>
<p><img src="/posts/myblog/6.png"></p>
<h4 id="编译并上传博客到Github仓库"><a href="#编译并上传博客到Github仓库" class="headerlink" title="编译并上传博客到Github仓库"></a>编译并上传博客到Github仓库</h4><p>在博客根目录执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo clean</span><br><span class="line">npx hexo generate</span><br><span class="line">npx hexo deploy	//上传Hexo目录下的public文件夹到Github仓库</span><br></pre></td></tr></table></figure>

<p>如果是第一次使用，则可能会提示登录Github账号，因为在2020年7月之后Github宣布使用Git需要基于令牌的身份验证，所以Git 操作进行身份验证时不再接受帐户密码。下面进行Git令牌配置操作。</p>
<h4 id="Git使用令牌登录"><a href="#Git使用令牌登录" class="headerlink" title="Git使用令牌登录"></a>Git使用令牌登录</h4><h5 id="进入个人设置页面"><a href="#进入个人设置页面" class="headerlink" title="进入个人设置页面"></a>进入个人设置页面</h5><p><img src="/posts/myblog/7.png"></p>
<h5 id="找到Developer-settings"><a href="#找到Developer-settings" class="headerlink" title="找到Developer settings"></a>找到Developer settings</h5><p><img src="/posts/myblog/8.png"></p>
<h5 id="进入Personal-access-tokens，使用Generate-new-token新建Token"><a href="#进入Personal-access-tokens，使用Generate-new-token新建Token" class="headerlink" title="进入Personal access tokens，使用Generate new token新建Token"></a>进入Personal access tokens，使用Generate new token新建Token</h5><p><img src="/posts/myblog/9.png"></p>
<p>在Note中填上名字或备注<br>Expiration中选择过期时间（我选择了无限期）<br>Select scopes中勾选repo就行，其他的可以不用开</p>
<p><img src="/posts/myblog/10.png"></p>
<p>然后拉到本页面最下面，点击Generate Token就行了</p>
<h5 id="如何使用令牌"><a href="#如何使用令牌" class="headerlink" title="如何使用令牌"></a>如何使用令牌</h5><p>将生成的令牌复制到剪贴板。使用Git上传文件到仓库时，提示登录账号时密码替换成Token即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号：你的Github账号</span><br><span class="line">密码：你刚才复制的Token</span><br></pre></td></tr></table></figure>

<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>个人域名需要提前购买，博主是从dnspod上购买的域名。</p>
<p>在仓库的Pages选项中填写你购买的个人域名</p>
<p><img src="/posts/myblog/11.png"></p>
<p>然后在域名提供商的控制面板中将对应的主机记录通过别名（CNAME）解析到你的Github Pages的域名</p>
<p><img src="/posts/myblog/12.png"></p>
<p>等待几分钟你就能使用你的个人域名访问Github Pages上的博客了</p>
<h2 id="给个人博客开启HTTPS"><a href="#给个人博客开启HTTPS" class="headerlink" title="给个人博客开启HTTPS"></a>给个人博客开启HTTPS</h2><p>在Github仓库中开启Enforce HTTPS</p>
<p><img src="/posts/myblog/13.png"></p>
<p>在域名提供商处申请免费SSL证书</p>
<p><img src="/posts/myblog/14.png"></p>
<p>等待证书颁发完成后，dnspod会自动在dns上做相关解析，现在就可以使用HTTPS+个人域名访问你的博客了</p>
<h2 id="使用CDN加速博客"><a href="#使用CDN加速博客" class="headerlink" title="使用CDN加速博客"></a>使用CDN加速博客</h2><p>域名绑定好了，但是发现有时候打开博客很慢，于是使用CDN加速博客。</p>
<p>为什么选择又拍云？<br>因为加入开发者联盟每个月有免费的加速流量。基本不用花钱。</p>
<h3 id="配置又拍云加速国内"><a href="#配置又拍云加速国内" class="headerlink" title="配置又拍云加速国内"></a>配置又拍云加速国内</h3><p>前提：域名已经通过备案    未备案的域名无法使用国内CDN服务</p>
<h4 id="加入又拍云联盟"><a href="#加入又拍云联盟" class="headerlink" title="加入又拍云联盟"></a>加入又拍云联盟</h4><h5 id="页面下方加入又拍云的logo和链接（申请加入的条件）"><a href="#页面下方加入又拍云的logo和链接（申请加入的条件）" class="headerlink" title="页面下方加入又拍云的logo和链接（申请加入的条件）"></a>页面下方加入又拍云的logo和链接（申请加入的条件）</h5><p>我使用主题的是butterfly，在Hexo根目录对_config.butterfly.yml文件的footer-custom_text进行修改即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt; img&#123; vertical-align:middle;&#125; &lt;/style&gt; &lt;a href=&quot;https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral&quot;&gt;&lt;span&gt;本站由 &lt;img class=&quot;upyun-icon&quot; src=&quot;/img/upyun.png&quot; width=&quot;5%&quot;&gt; 提供CDN加速/云存储服务&lt;/span&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/myblog/15.png"></p>
<p>效果展示</p>
<p><img src="/posts/myblog/16.png"></p>
<h5 id="在活动相关页面申请加入又拍云开发者联盟"><a href="#在活动相关页面申请加入又拍云开发者联盟" class="headerlink" title="在活动相关页面申请加入又拍云开发者联盟"></a>在活动相关页面申请加入又拍云开发者联盟</h5><p><a href="https://www.upyun.com/league">https://www.upyun.com/league</a></p>
<h4 id="在控制台中创建CDN加速服务"><a href="#在控制台中创建CDN加速服务" class="headerlink" title="在控制台中创建CDN加速服务"></a>在控制台中创建CDN加速服务</h4><p><img src="/posts/myblog/17.png"></p>
<p>需要注意的是，源站证书校验需要关闭，否则可能后续访问的时候经常出现报错”certificate has expired”</p>
<h3 id="在dns上设置别名解析"><a href="#在dns上设置别名解析" class="headerlink" title="在dns上设置别名解析"></a>在dns上设置别名解析</h3><p>加速服务创建好了，现在我们只需要设置以下dns解析就能开启cdn加速了</p>
<p><img src="/posts/myblog/18.png"></p>
<p><img src="/posts/myblog/19.png"></p>
<p><img src="/posts/myblog/20.png"></p>
<p>刚才指向yuukipix.github.io的CNAME需要更改为境外</p>
<p>CND加速配置完成</p>
<h3 id="优化CDN"><a href="#优化CDN" class="headerlink" title="优化CDN"></a>优化CDN</h3><p>开启HTTPS</p>
<p><img src="/posts/myblog/21.png"></p>
<p>开启性能优化</p>
<p><img src="/posts/myblog/22.png"></p>
<p><img src="/posts/myblog/23.png"></p>
<p><img src="/posts/myblog/24.png"></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖配置阿里云Docker镜像加速服务</title>
    <url>/posts/synology-docker-mirror-acceleration/</url>
    <content><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>环境DSM 6.2.3<br>Docker套件版本：18</p>
<h1 id="群晖Web界面设置"><a href="#群晖Web界面设置" class="headerlink" title="群晖Web界面设置"></a>群晖Web界面设置</h1><p>先找到阿里云镜像加速服务，开通<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a><br><img src="/posts/synology-docker-mirror-acceleration/1.png"></p>
<p>可在Docker套件-注册表中进行如下设置进行加速<br><img src="/posts/synology-docker-mirror-acceleration/2.png"></p>
<h1 id="SSH连接群晖修改配置文件（可选）"><a href="#SSH连接群晖修改配置文件（可选）" class="headerlink" title="SSH连接群晖修改配置文件（可选）"></a>SSH连接群晖修改配置文件（可选）</h1><p>也可以使用ssh连接到群晖，编辑以下文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /var/packages/Docker/etc/dockerd.json</span><br></pre></td></tr></table></figure>

<p><img src="/posts/synology-docker-mirror-acceleration/3.png"><br>保险起见，再修改一下这两个配置文件。这两个文件互相映射，改哪个都一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /var/packages/Docker/target/config/dockerd.json</span><br><span class="line">vi /volume1/@appstore/Docker/config/dockerd.json	//volume1是套件保存的位置，根据自己实际情况填写</span><br></pre></td></tr></table></figure>

<p><img src="/posts/synology-docker-mirror-acceleration/4.png"><br>测试安装一下镜像，速度不错。<br>不过下载Jellyfin依旧可能报错，不知道为什么。</p>
<h1 id="解决Jellyfin多次下载失败"><a href="#解决Jellyfin多次下载失败" class="headerlink" title="解决Jellyfin多次下载失败"></a>解决Jellyfin多次下载失败</h1><p>如果多次下载Jellyfin还是失败，试试直接ssh连上群晖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull jellyfin/jellyfin</span><br></pre></td></tr></table></figure>

<p>这下就不会失败了，等待一会下载好后会在映像中显示出来<br><img src="/posts/synology-docker-mirror-acceleration/5.png"></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>黑群晖</tag>
      </tags>
  </entry>
  <entry>
    <title>黑群晖重做引导进行群晖升级</title>
    <url>/posts/synology-update/</url>
    <content><![CDATA[<h2 id="方法一（测试可用，不推荐）"><a href="#方法一（测试可用，不推荐）" class="headerlink" title="方法一（测试可用，不推荐）"></a>方法一（测试可用，不推荐）</h2><p>重做引导开机后发现进不去系统，于是把所有磁盘拔出，留下一个相对来说不重要的盘</p>
<p>将留下的盘插入电脑，使用Diskgenius删除那个硬盘的主分区（粉色的）插入NAS后开机等待回恢复</p>
<p>等待重启后找到群晖对应IP就可以安装系统了，但是原来的系统设置可能不会保留下来，共享文件夹中的数据还在，套件的数据还在，Docker的容器也在（格的不是安装套件那个盘的话）</p>
<p><strong>缺点：会丢失系统设置数据 会丢失某些套件数据</strong></p>
<p><img src="/posts/synology-update/8.png"></p>
<h2 id="方法二（未测试）"><a href="#方法二（未测试）" class="headerlink" title="方法二（未测试）"></a>方法二（未测试）</h2><p>修改引导中的grub.cfg中的sn和mac字段。此时重新开机后应该会提示从硬盘中进行恢复。记得恢复完成后sn和mac要改回去。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>黑群晖</tag>
        <tag>翻车</tag>
      </tags>
  </entry>
</search>
